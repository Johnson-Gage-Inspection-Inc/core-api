# JGI Flask API - GitHub Copilot Instructions

## Quick Reference
- **Main Documentation**: [`README.md`](../README.md)
- **Testing Guide**: [`TESTING.md`](../TESTING.md)
- **API Specification**: [Qualer SDK OpenAPI](https://raw.githubusercontent.com/Johnson-Gage-Inspection-Inc/qualer-sdk-python/refs/heads/master/spec.json)

## Project Overview
This is a Flask-based REST API for Johnson Gage and Inspection, Inc. (JGI) that serves as an internal API for quality management operations. The API integrates with Microsoft Entra ID for authentication and the Qualer quality management system for data operations.

## Project Structure

### Core Application Files
- `app.py` - Main Flask application with blueprint registration, authentication setup, and OpenAPI configuration
- `config.py` - Environment configuration loader
- `schemas.py` - Marshmallow schemas for request/response serialization with dynamic schema generation from Qualer SDK models
- `requirements.txt` - Python dependencies including Flask, authentication libraries, and Qualer SDK

### Routes (`/routes/`)
All API endpoints are organized as Flask-Smorest blueprints:
- `whoami.py` - User authentication info endpoint
- `work_item_details.py` - Work item details from Qualer system
- `pyro_assets.py` - Pyrotechnic assets from specific asset pool
- `employees.py` - Employee listing from Qualer
- `clients.py` - Client companies from Qualer system
- `git_ops.py` - Deployment automation endpoint (uses separate token auth)

### Utilities (`/utils/`)
- `auth.py` - Authentication decorators and JWT token validation with Azure AD
- `qualer_client.py` - Qualer SDK client configuration and authentication
- `get_token.py` - MSAL helper for acquiring Azure AD tokens during development

### Testing Framework (`/tests/`)

#### **üö® GOLDEN RULE: All test files MUST be placed in `/tests/` directory with `test_*.py` naming convention**

#### Special Testing Files
- `conftest.py` - pytest fixtures including session-scoped auth token and test client
- `mock_view_bindings.py` - Mock implementations for protected endpoints when `SKIP_AUTH=true`
- `__init__.py` - Makes tests directory a Python package

**Key Testing Architecture Notes**:
- `mock_view_bindings.py` automatically replaces view functions when `SKIP_AUTH=true`
- This enables fast testing without external dependencies but can interfere with error testing
- Error handling tests may need to temporarily restore real view functions
- Session-scoped `auth_token` fixture prevents repeated authentication calls
- `reset_auth_cache` fixture prevents cross-test contamination

#### Test Coverage
Each major component has corresponding test files:
- `test_app.py` - Main application and core functionality tests
- `test_auth.py` - Authentication system, token validation, and decorators
- `test_whoami.py` - `/whoami` endpoint tests
- `test_work_item_details.py` - Work item details endpoint and business logic
- `test_pyro_assets.py` - Pyrotechnic assets endpoint
- `test_employees.py` - Employee listing endpoint
- `test_clients.py` - Client companies endpoint tests
- `test_git_ops.py` - Git operations endpoint
- `test_qualer_client.py` - Qualer SDK client configuration
- `test_get_token.py` - Token acquisition utilities
- `test_config.py` - Configuration loading

## Development Guidelines

### Authentication Architecture
- **Primary Auth**: Microsoft Entra ID OAuth 2.0 with JWT tokens
- **Token Validation**: Uses Azure's JWKS endpoints for public key verification
- **Required Scope**: `access_as_user`
- **Auth Decorator**: `@require_auth` from `utils.auth`
- **Test Auth**: Use `SKIP_AUTH=true` environment variable with mock bindings

### API Design Patterns
- **Framework**: Flask with Flask-Smorest for OpenAPI/Swagger integration
- **Blueprints**: All routes organized as blueprints registered with `api` (not `app`)
- **Schemas**: Use Marshmallow for serialization, auto-generate from Qualer SDK models when possible
- **Documentation**: OpenAPI 3.0 with Swagger UI at `/docs`
- **Security**: All endpoints require Bearer token authentication (except `/` and git-ops)

### External Integrations
- **Qualer SDK**: Primary integration for quality management data
  - **API Specification**: https://raw.githubusercontent.com/Johnson-Gage-Inspection-Inc/qualer-sdk-python/refs/heads/master/spec.json
  - **Complete OpenAPI/Swagger documentation** for all available endpoints, models, and properties
- **Azure AD**: Authentication and user management
- **Git Operations**: Automated deployment via webhook-style endpoint

### Testing Best Practices

#### Test File Organization
- **Location**: ALL test files must be in `/tests/` directory
- **Naming**: Use `test_*.py` pattern for all test files
- **Structure**: Mirror the main code structure (e.g., `test_auth.py` for `utils/auth.py`)

#### Mock Strategy
- Use `mock_view_bindings.py` for endpoint mocking during development
- Use `unittest.mock` for unit testing external dependencies
- Session-scoped `auth_token` fixture for integration tests
- Test client fixture in `conftest.py`

#### Test Categories
- **Unit Tests**: Mock external dependencies, test individual functions
- **Integration Tests**: Use real auth tokens and test full request/response cycles
- **Authentication Tests**: Verify token validation, scope checking, error handling
- **Endpoint Tests**: Test all API routes with various input scenarios

#### Testing Environment Compatibility

**‚ö†Ô∏è IMPORTANT**: For comprehensive testing guidance, see [`TESTING.md`](../TESTING.md) for environment setup, coverage goals, error-handling strategies, and centralized mock utilities

**Key Requirements**:
- Tests must work in both VS Code Test Runner and terminal pytest
- Support dual authentication modes (`SKIP_AUTH=true/false`)
- Achieve 80%+ coverage for GitHub CI

**Common Patterns**:
- Use view function restoration for error testing when `SKIP_AUTH=true`
- Implement SDK-level patching for cross-environment compatibility
- Use conditional assertions based on authentication mode
- Reset global state between tests with `autouse=True` fixtures

### Environment Configuration
- **Development**: Use `.env` file with Azure AD and Qualer credentials (ensure `.env` is in `.gitignore`)
- **Testing**: Set `SKIP_AUTH=true` to use mock authentication
- **Required Variables**: 
  - `AZURE_TENANT_ID`, `AZURE_CLIENT_ID` (Azure AD)
  - `QUALER_API_KEY` (Qualer integration - header-style token: `Api-Token xyz`)
  - `DEPLOY_TOKEN` (Git operations)
- **Security**: Rotate `QUALER_API_KEY` every 90 days and audit Azure AD roles regularly

### Code Style Guidelines
- **Import Organization**: Standard library, third-party, local imports
- **Error Handling**: Use Flask-Smorest `abort()` for API errors
- **Logging**: Use Flask's built-in logging for debugging
- **Documentation**: Include docstrings for complex business logic
- **Type Hints**: Encourage type hints for better code clarity

### Copilot Prompting Tips
**Effective Prompts for Common Tasks**:
- **New Endpoint**: "Add a GET route to `/calibration` that fetches calibration details using `@require_auth` and Qualer SDK"
- **Testing**: "Write pytest for `/calibration` route using mocked Qualer SDK call with success and error scenarios"
- **Schema Generation**: "Create Marshmallow schema for CalibrationResponse using Qualer SDK model"
- **Error Handling**: "Add proper error handling with Flask-Smorest abort() for API timeouts"

**Copilot Code Guidance**:
- Use inline comments like `# TODO Copilot: expand with pagination logic` to guide future edits
- Prefix complex functions with `# Copilot: This function handles...` for context
- When debugging, add `# DEBUG: Expected behavior is...` comments

### Deployment Considerations
- **Production URL**: `https://api.jgiquality.com`
- **Proxy Support**: Uses ProxyFix middleware for reverse proxy deployment
- **CORS**: Enabled for cross-origin requests from Excel/Power Query
- **Git Deployment**: Automated via `/git-pull` endpoint

## Common Development Tasks

### Adding New Endpoints
1. Create route file in `/routes/` as Flask-Smorest blueprint
2. Add authentication with `@require_auth` decorator
3. Define schemas in `schemas.py` for request/response
4. Register blueprint in `app.py`
5. Create corresponding test file in `/tests/test_*.py`
6. Add mock implementation in `mock_view_bindings.py` if needed

### Testing New Features
1. Write tests following the **üö® GOLDEN RULE** above
2. Use existing fixtures from `conftest.py`
3. Mock external dependencies appropriately
4. Test both authenticated and unauthenticated scenarios
5. Verify OpenAPI schema generation
6. **See [`TESTING.md`](../TESTING.md) for detailed patterns and strategies**

### Running Tests

```powershell
# Full test suite with coverage
python -m pytest --cov=. --cov-report=term-missing

# Test with specific auth mode
$env:SKIP_AUTH="false"; python -m pytest  # Production mode
$env:SKIP_AUTH="true"; python -m pytest   # CI mode (default)
```

**Coverage Targets**: 80% minimum for CI, 90%+ achievable locally
**See [`TESTING.md`](../TESTING.md) for comprehensive testing commands and debugging techniques**

### External API Integration
1. Add client configuration in `/utils/`
2. Handle authentication/API keys properly
3. Create comprehensive error handling
4. Write unit tests with mocked external calls
5. Document any new environment variables needed

## Security Considerations
- **Secret Management**: Never commit API keys or secrets to git (ensure `.env` is in `.gitignore`)
- **Environment Variables**: Use environment variables for all configuration
- **Input Validation**: Validate all input parameters
- **Token Security**: Implement proper scope checking for Azure AD tokens
- **Audit Logging**: Log security-relevant events for monitoring
- **Secret Rotation**: Replace `QUALER_API_KEY` every 90 days and audit Azure AD roles regularly

## Troubleshooting

### General Issues
- Check environment variables if authentication fails
- Use `SKIP_AUTH=true` for development without Azure AD setup
- Verify Qualer API key permissions for data access issues
- Check Flask logs for detailed error information
- Ensure all blueprints are registered with `api` not `app`

### Testing Issues
**For comprehensive testing troubleshooting, see [`TESTING.md`](../TESTING.md)**

**Quick Fixes**:
- Tests fail in VS Code but pass in terminal ‚Üí Use SDK-level patches
- Mocks don't work with `SKIP_AUTH=true` ‚Üí Use view function restoration pattern  
- Different results between auth modes ‚Üí Use conditional assertions
- Import errors ‚Üí Ensure test files are in `/tests/` directory

### Debugging & File Editing Best Practices

**‚ö†Ô∏è CRITICAL**: When using Copilot commands like `replace_string_in_file`, always call `read_file` first to confirm your match is accurate

#### Copilot File Editing Workflow
1. **Check Current State**: Always use `read_file` to examine file contents before editing
2. **Verify Syntax**: Use `get_errors` to check for syntax issues after failed edits
3. **Targeted Fixes**: Use `replace_string_in_file` with 5-7 lines of context for precision
4. **Immediate Validation**: Run tests immediately after code changes with `run_tests`
5. **File Recreation**: Consider `create_file` for completely rewriting corrupted files

#### Common Edit Failures & Solutions
- **String replacement fails**: File contents don't match expected format
  - **Solution**: Use `read_file` to see actual content, then adjust `oldString`
- **Import/syntax errors after edits**: Missing newlines or malformed code
  - **Solution**: Check file with `get_errors`, then fix specific syntax issues
- **Tests fail with AttributeError**: Incorrect import statements or method calls
  - **Solution**: Verify imports and API usage patterns in similar files

#### Error Diagnosis Strategy
1. **File State Check**: Read the failing file to understand current structure
2. **Error Analysis**: Use `get_errors` to identify syntax/import issues  
3. **Pattern Matching**: Check similar working files for correct patterns
4. **Targeted Repair**: Make minimal changes to fix specific issues
5. **Test Validation**: Verify fixes with focused test runs

#### String Replacement Best Practices
- **Context Lines**: Include 5-7 lines before/after target for unique matching
- **Whitespace Accuracy**: Preserve exact indentation and line endings
- **Unique Strings**: Ensure `oldString` appears only once in the file
- **Fallback Strategy**: If replacement fails twice, use `read_file` to reassess

#### Testing Integration
- **Immediate Testing**: Run `run_tests` after each significant change
- **Focused Testing**: Use specific file paths to avoid long test runs
- **Error Handling Tests**: May require view function restoration with `SKIP_AUTH=true`
- **Cross-Environment**: Ensure tests work in both VS Code and terminal