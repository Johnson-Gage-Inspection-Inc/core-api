# JGI Flask API - GitHub Copilot Instructions

## Project Overview
This is a Flask-based REST API for Johnson Gage and Inspection, Inc. (JGI) that serves as an internal API for quality management operations. The API integrates with Microsoft Entra ID for authentication and the Qualer quality management system for data operations.

## Project Structure

### Core Application Files
- `app.py` - Main Flask application with blueprint registration, authentication setup, and OpenAPI configuration
- `config.py` - Environment configuration loader
- `schemas.py` - Marshmallow schemas for request/response serialization with dynamic schema generation from Qualer SDK models
- `requirements.txt` - Python dependencies including Flask, authentication libraries, and Qualer SDK

### Routes (`/routes/`)
All API endpoints are organized as Flask-Smorest blueprints:
- `whoami.py` - User authentication info endpoint
- `work_item_details.py` - Work item details from Qualer system
- `pyro_assets.py` - Pyrotechnic assets from specific asset pool
- `employees.py` - Employee listing from Qualer
- `git_ops.py` - Deployment automation endpoint (uses separate token auth)

### Utilities (`/utils/`)
- `auth.py` - Authentication decorators and JWT token validation with Azure AD
- `qualer_client.py` - Qualer SDK client configuration and authentication
- `get_token.py` - MSAL helper for acquiring Azure AD tokens during development

### Testing Framework (`/tests/`)

#### **CRITICAL: All test files MUST be placed in `/tests/` directory with `test_*.py` naming convention**

#### Special Testing Files
- `conftest.py` - pytest fixtures including session-scoped auth token and test client
- `mock_view_bindings.py` - Mock implementations for protected endpoints when `SKIP_AUTH=true`
- `__init__.py` - Makes tests directory a Python package

**Key Testing Architecture Notes**:
- `mock_view_bindings.py` automatically replaces view functions when `SKIP_AUTH=true`
- This enables fast testing without external dependencies but can interfere with error testing
- Error handling tests may need to temporarily restore real view functions
- Session-scoped `auth_token` fixture prevents repeated authentication calls
- `reset_auth_cache` fixture prevents cross-test contamination

#### Test Coverage
Each major component has corresponding test files:
- `test_app.py` - Main application and core functionality tests
- `test_auth.py` - Authentication system, token validation, and decorators
- `test_whoami.py` - `/whoami` endpoint tests
- `test_work_item_details.py` - Work item details endpoint and business logic
- `test_pyro_assets.py` - Pyrotechnic assets endpoint
- `test_employees.py` - Employee listing endpoint
- `test_git_ops.py` - Git operations endpoint
- `test_qualer_client.py` - Qualer SDK client configuration
- `test_get_token.py` - Token acquisition utilities
- `test_config.py` - Configuration loading

## Development Guidelines

### Authentication Architecture
- **Primary Auth**: Microsoft Entra ID OAuth 2.0 with JWT tokens
- **Token Validation**: Uses Azure's JWKS endpoints for public key verification
- **Required Scope**: `access_as_user`
- **Auth Decorator**: `@require_auth` from `utils.auth`
- **Test Auth**: Use `SKIP_AUTH=true` environment variable with mock bindings

### API Design Patterns
- **Framework**: Flask with Flask-Smorest for OpenAPI/Swagger integration
- **Blueprints**: All routes organized as blueprints registered with `api` (not `app`)
- **Schemas**: Use Marshmallow for serialization, auto-generate from Qualer SDK models when possible
- **Documentation**: OpenAPI 3.0 with Swagger UI at `/docs`
- **Security**: All endpoints require Bearer token authentication (except `/` and git-ops)

### External Integrations
- **Qualer SDK**: Primary integration for quality management data
- **Azure AD**: Authentication and user management
- **Git Operations**: Automated deployment via webhook-style endpoint

### Testing Best Practices

#### Test File Organization
- **Location**: ALL test files must be in `/tests/` directory
- **Naming**: Use `test_*.py` pattern for all test files
- **Structure**: Mirror the main code structure (e.g., `test_auth.py` for `utils/auth.py`)

#### Mock Strategy
- Use `mock_view_bindings.py` for endpoint mocking during development
- Use `unittest.mock` for unit testing external dependencies
- Session-scoped `auth_token` fixture for integration tests
- Test client fixture in `conftest.py`

#### Test Categories
- **Unit Tests**: Mock external dependencies, test individual functions
- **Integration Tests**: Use real auth tokens and test full request/response cycles
- **Authentication Tests**: Verify token validation, scope checking, error handling
- **Endpoint Tests**: Test all API routes with various input scenarios

#### Testing Environment Compatibility

##### **CRITICAL: VS Code Test Runner vs Terminal pytest Compatibility**

The project supports multiple test execution environments with different behaviors:

**Terminal pytest (`python -m pytest`)**:
- Direct module imports and patches work consistently
- Full control over mock timing and scope
- Imports cached once per session

**VS Code Test Runner**:
- Different import caching behavior
- Module patches may not take effect due to import timing
- Requires special handling for complex mocking scenarios

**Compatibility Strategies**:

1. **Mock View Function Restoration for Error Testing**:
   ```python
   def test_error_condition(client, auth_token):
       import os
       from app import app
       
       # If SKIP_AUTH=true, temporarily restore real view function
       skip_auth = os.getenv("SKIP_AUTH", "false").lower() == "true"
       original_view_func = None
       
       if skip_auth:
           from routes.my_route import MyRouteClass
           original_view_func = app.view_functions.get("blueprint.ViewName")
           app.view_functions["blueprint.ViewName"] = MyRouteClass().get
       
       try:
           # Test with SDK patches that need real code paths
           with patch("routes.my_route.ExternalAPI") as mock_api:
               mock_api.return_value.method.return_value = error_condition
               # Test error handling...
       finally:
           if skip_auth and original_view_func:
               app.view_functions["blueprint.ViewName"] = original_view_func
   ```

2. **SDK-Level Patching**: Patch at the SDK/external library level rather than function level for better compatibility across test runners.

3. **Test Isolation**: Use `autouse=True` fixtures to reset global state between tests.

##### **Dual Mode Testing (`SKIP_AUTH=true` vs `SKIP_AUTH=false`)**

**`SKIP_AUTH=true` (CI/Development Mode)**:
- Uses `mock_view_bindings.py` for fast, fake responses
- Some auth tests skipped with `@pytest.mark.skipif`
- Enables testing without Azure AD setup
- Coverage target: 80%+ for GitHub CI

**`SKIP_AUTH=false` (Production Mode)**:
- Full authentication required
- All tests execute real auth paths
- Requires valid Azure AD tokens
- Higher coverage possible: 90%+

**Patterns for Dual Mode Tests**:
```python
import os

def test_endpoint_behavior(client, auth_token):
    skip_auth = os.getenv("SKIP_AUTH", "false").lower() == "true"
    
    response = client.get("/endpoint", headers={"Authorization": f"Bearer {auth_token}"})
    
    if skip_auth:
        # Expect mock behavior
        assert response.status_code == 200
        assert response.get_json()["user"] == "testuser@example.com"
    else:
        # Expect real auth behavior
        assert response.status_code == 200
        assert "@" in response.get_json()["user"]  # Real email

@pytest.mark.skipif(os.getenv("SKIP_AUTH", "false").lower() == "true", 
                   reason="Skipped when SKIP_AUTH=true")
def test_auth_specific_feature(client, auth_token):
    # Test only runs in production mode
    pass
```

##### **Test Coverage Strategies**

**For GitHub CI (SKIP_AUTH=true)**:
- Target: 80% minimum coverage
- Focus on business logic and error handling
- Use mock implementations for external dependencies
- Skip Azure AD specific tests

**For Local Development**:
- Target: 90%+ coverage possible with real auth
- Test complete auth flows
- Validate external API integrations
- Full error path coverage

**Coverage-Friendly Test Patterns**:
- Test both success and error paths for each endpoint
- Use parametrized tests for multiple input scenarios
- Mock external dependencies to test error conditions
- Include edge cases and validation errors

##### **Common Testing Pitfalls and Solutions**

**Problem**: Mock patches don't work in VS Code Test Runner
**Solution**: Use SDK-level patches and view function restoration

**Problem**: Tests pass in terminal but fail in VS Code
**Solution**: Check for import timing issues and global state pollution

**Problem**: Different coverage between SKIP_AUTH modes
**Solution**: Design tests to work in both modes with conditional expectations

**Problem**: Authentication tests fail without Azure AD setup
**Solution**: Use skip decorators and mock tokens appropriately

### Environment Configuration
- **Development**: Use `.env` file with Azure AD and Qualer credentials
- **Testing**: Set `SKIP_AUTH=true` to use mock authentication
- **Required Variables**: 
  - `AZURE_TENANT_ID`, `AZURE_CLIENT_ID` (Azure AD)
  - `QUALER_API_KEY` (Qualer integration)
  - `DEPLOY_TOKEN` (Git operations)

### Code Style Guidelines
- **Import Organization**: Standard library, third-party, local imports
- **Error Handling**: Use Flask-Smorest `abort()` for API errors
- **Logging**: Use Flask's built-in logging for debugging
- **Documentation**: Include docstrings for complex business logic
- **Type Hints**: Encourage type hints for better code clarity

### Deployment Considerations
- **Production URL**: `https://api.jgiquality.com`
- **Proxy Support**: Uses ProxyFix middleware for reverse proxy deployment
- **CORS**: Enabled for cross-origin requests from Excel/Power Query
- **Git Deployment**: Automated via `/git-pull` endpoint

## Common Development Tasks

### Adding New Endpoints
1. Create route file in `/routes/` as Flask-Smorest blueprint
2. Add authentication with `@require_auth` decorator
3. Define schemas in `schemas.py` for request/response
4. Register blueprint in `app.py`
5. Create corresponding test file in `/tests/test_*.py`
6. Add mock implementation in `mock_view_bindings.py` if needed

### Testing New Features
1. Write tests in `/tests/test_*.py` (never in other locations)
2. Use existing fixtures from `conftest.py`
3. Mock external dependencies appropriately
4. Test both authenticated and unauthenticated scenarios
5. Verify OpenAPI schema generation
6. **Test in both VS Code Test Runner and terminal pytest**
7. **Ensure tests work with both `SKIP_AUTH=true` and `SKIP_AUTH=false`**
8. **Use view function restoration pattern for error testing when `SKIP_AUTH=true`**

### Testing Tools and Commands

#### Running Tests
```powershell
# Full test suite with coverage
python -m pytest --cov=. --cov-report=term-missing

# Specific test file
python -m pytest tests/test_specific_file.py

# Test with production auth mode
$env:SKIP_AUTH="false"; python -m pytest

# Test with CI mode (default)
$env:SKIP_AUTH="true"; python -m pytest

# Run in VS Code Test Runner
# Use Testing panel in VS Code sidebar
```

#### Coverage Targets
- **GitHub CI**: 80% minimum with `SKIP_AUTH=true`
- **Local Development**: 90%+ achievable with `SKIP_AUTH=false`
- **Critical Files**: Routes and utils should have >95% coverage

#### Test Debugging
```powershell
# Verbose output
python -m pytest -v

# Stop on first failure
python -m pytest -x

# Run only failed tests from last run
python -m pytest --lf

# Debug with pdb
python -m pytest --pdb
```

### External API Integration
1. Add client configuration in `/utils/`
2. Handle authentication/API keys properly
3. Create comprehensive error handling
4. Write unit tests with mocked external calls
5. Document any new environment variables needed

## Security Considerations
- Never commit API keys or secrets to git
- Use environment variables for all configuration
- Validate all input parameters
- Implement proper scope checking for Azure AD tokens
- Log security-relevant events for monitoring

## Troubleshooting

### General Issues
- Check environment variables if authentication fails
- Use `SKIP_AUTH=true` for development without Azure AD setup
- Verify Qualer API key permissions for data access issues
- Check Flask logs for detailed error information
- Ensure all blueprints are registered with `api` not `app`

### Testing Issues

#### "Tests pass in terminal but fail in VS Code Test Runner"
- **Cause**: Different import caching and module loading behavior
- **Solution**: Use SDK-level patches instead of function-level patches
- **Solution**: Implement view function restoration pattern for error tests
- **Example**: See `test_work_item_details.py` error handling tests

#### "Mocks don't work when SKIP_AUTH=true"
- **Cause**: `mock_view_bindings.py` intercepts requests before patches apply
- **Solution**: Temporarily restore real view functions for error testing
- **Pattern**: Check `skip_auth` flag and swap view functions in test

#### "Different test results between SKIP_AUTH modes"
- **Cause**: Different code paths and response structures
- **Solution**: Use conditional assertions based on auth mode
- **Example**: Status codes may differ (400 vs 422) between modes

#### "Coverage drops significantly with SKIP_AUTH=true"
- **Cause**: Auth-specific code paths are skipped
- **Solution**: Use `@pytest.mark.skipif` for auth-only tests
- **Target**: 80% coverage acceptable for CI mode

#### "Import errors or module not found in tests"
- **Cause**: Incorrect test file location or missing `__init__.py`
- **Solution**: Ensure all test files are in `/tests/` directory
- **Solution**: Check that `/tests/__init__.py` exists

#### "Global state pollution between tests"
- **Cause**: Cached values in modules (especially auth caches)
- **Solution**: Use `reset_auth_cache` fixture (see `conftest.py`)
- **Solution**: Add `autouse=True` fixtures to clean up state